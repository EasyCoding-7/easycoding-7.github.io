---
layout: post
title:  "(Win32 : WindowsProgramming-3) 어셈블리 기본문법"
summary: ""
author: win32
date: '2021-05-07 0:00:00 +0000'
category: ['win32', 'WindowsProgramming']
#tags: ['C++', 'tag-test1']
thumbnail: /assets/img/posts/thumbnail-win32-api.png
#keywords: ['C++ 글올리기', 'kw-test1']
usemathjax: false
permalink: /blog/win32/WindowsProgramming-3/
---

## 어셈블리 코드 해석

```cpp
#include <stdio.h>

int asm_main();     // 어셈블리 파일로 만들예정

int main()
{
    int n = asm_main();
    printf("result : %d\n", n);
}
```

```
; asm1.asm  ; 어셈블리는 세미콜론이 주석

.model flat

public _asm_main

.code
_asm_main:
    mov     eax, 100        ; return 100과 동일
    ret

end     ; 파일의 끝에는 항상 end가 있어야 한다.
```

* cpp에서는 함수의 이름을 `asm_main()`로 선언했는데 어셈블리에선 `_asm_main`라 정의한 이유??<br>
cl컴파일러는 함수의 이름 앞에 `_`를 붙여서 쓴다. cl컴파일러의 규칙을 따르기 위해서 추가함.

* `.model flat` 란? <br>
memory model을 flat으로 해달라 이외에 language-type, stack-option등을 지정할 수 있다.

```
.model flat
.model flat, c          ; language-type을 c로
.model float, stdcall   ; language-type을 stdcall로
```

더 자세한 사항은 이후에 language-type을 설명할때 추가함.

---

## PE Format

```

Header
-------
Section .text (함수)
Section .data (전역 변수)
...

```

이런식으로 실행파일이 관리된다.

```
.model flat

public _asm_main ; 다른 함수에서도 부르게 해달라는 명령(c에서 부를수 있게 된다.)

.data
; 전역 변수

.code   ; .text 를 의미함.
_asm_main:
    mov     eax, 100
    ret ; 함수 종료를 의미

end
```

PE에 관해서는 이후 DLL설명에서 추가설명을 넣음.

---

## 또 다른 어셈블리 표기법

```
.model flat

public _asm_main

.code
_asm_main proc  ; 콜론대신 proc표기가능 
    mov     eax, 100
    ret
_asm_main endp

end
```

```
.model flat

public _asm_main

_DATA SEGMENT   ; .data와 동일
_DATA ends

_TEXT SEGMENT    ; .code 대신에 _TEXT SEGMENT 표기가능

_asm_main proc
    mov     eax, 100
    ret
_asm_main endp

_TEXT ends

end
```

---

## C를 어셈블리 파일로 생성하기

```
$ cl asm1.c /FAs /c
```

* `/FAs` : 어셈블리를 만들어 달라
* `/c` : 컴파일만 해달라

---

## Data section

```
.model flat
public _asm_main

.data
L1  DWORD   100     ; 4바이트 할당 100을 넣어라
L2  DD      200     ; DD = DWORD와 동일어

.code
_asm_main:
    mov     eax, L1 ; 100이 리턴

    ; 메모리 복사
    ; mov     L1, L2  ; 컴파일 에러 : 2개의 오퍼랜드가 모두 메모리일 수 없다.
    mov     ebx, L2
    mov     L1, ebx
    ; 이런식으로 해야함

    ; 메모리 주소값 구하기
    ; ebx = &L1
    mov     ebx, offset L1  ; L1의 메모리주소를 넣어라
    mov     eax, [ebx]      ; []를 할시 주소의 값을 리턴

    ; ebx = 300
    ; mov     [ebx], 300      ; 에러 : 300을 몇바이트로 넣을지 미정
    mov     dword ptr[ebx], 300

    ret

end
```

```
; 배열 만들어 보기
.model flat
public _asm_main

.data
; L1   DD   100
L1   DD   100, 200, 300, 400
L2   DD   4 dup (100) ; 100, 100, 100, 100
; 4개의 100을 넣어달라

.code
_asm_main:
    ; mov eax, L1
    mov esi, offset L1
    mov eax dword ptr[esi+4]
    ret

end
```

---

## 함수 호출의 원리

### jump 함수호출

```
.model flat

public _asm_main
public _foo

.code
_asm_main:
    mov eax, 100
    ret

_foo:   ; 역시 c에서 호출하고 싶다면 _를 붙이자

end
```

```
_asm_main:
    mov eax, 100
    ; mov ebx, 돌아올 주소
    mov ebx, POS_A
    jmp _add ; 함수 호출
POS_A:
    ret

_add:
    mov eax, 300
    jmp ebx
```

레지스터는 자원이 한정적이기에 스텍에 돌아올 주소를 넣어보자

```
_asm_main:
    mov eax, 100
    ; mov ebx, 돌아올 주소
    push POS_A
    jmp _add ; 함수 호출
POS_A:
    ret

_add:
    mov eax, 300
    pop ebx ; ebx에 pop해달라
    jmp ebx
```

### call 함수호출

```
_asm_main:
    mov eax, 100
    call _add   ; 스택에 넣고 돌아올 주소까지 할당
    ret

_add:
    mov eax, 300
    ret         ; 스택에 꼭대기에 돌아갈 주소가 있다고 가정
```

* 결론 : `call, ret`을 쓰자

### C언어에서 함수 호출?

```cpp
int add()
{
    return 300;
}

int main()
{
    add();
}
```

이걸 어셈블리로 만들어 보자.

```
cl call.c /FAs
```

결론은 call, ret을 VS에서도 그대로 쓴다는 것을 확인하는 것이다.

```
; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29914.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	add
PUBLIC	main
pdata	SEGMENT
$pdata$main DD	imagerel $LN3
	DD	imagerel $LN3+16
	DD	imagerel $unwind$main
pdata	ENDS
xdata	SEGMENT
$unwind$main DD	010401H
	DD	04204H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\Git\Example\Example\call.c
_TEXT	SEGMENT
main	PROC

; 7    : {

$LN3:
	sub	rsp, 40					; 00000028H

; 8    :     add();

	call	add

; 9    : }

	xor	eax, eax
	add	rsp, 40					; 00000028H
	ret	0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Git\Example\Example\call.c
_TEXT	SEGMENT
add	PROC

; 3    :     return 300;

	mov	eax, 300				; 0000012cH

; 4    : }

	ret	0
add	ENDP
_TEXT	ENDS
END

```